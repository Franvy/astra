---
title: 全栈开发中的状态管理
description: 深入探讨现代全栈应用中的状态管理策略，包括客户端状态、服务器状态、全局状态和持久化方案
author: Claude AI
date: 2024-11-21
---

状态管理是全栈开发中最具挑战性的问题之一。本文将从前端到后端，全面解析现代应用中的状态管理策略和最佳实践。

## 状态的分类

在全栈应用中，我们需要管理多种类型的状态：

### 1. 客户端状态 (Client State)

仅存在于客户端的临时状态，如 UI 状态、表单输入等。

### 2. 服务器状态 (Server State)

存储在服务器上的数据，需要通过 API 获取和更新。

### 3. URL 状态 (URL State)

存储在 URL 中的状态，如查询参数、路由参数。

### 4. 全局状态 (Global State)

需要在多个组件间共享的状态。

## 前端状态管理

### React 状态管理演进

```typescript
// 1. 组件本地状态 - useState
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

// 2. 跨组件状态 - useContext
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');

  const toggleTheme = useCallback(() => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  }, []);

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// 使用
function Header() {
  const { theme, toggleTheme } = useTheme();

  return (
    <header className={theme}>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </header>
  );
}

// 3. 复杂状态逻辑 - useReducer
interface State {
  user: User | null;
  loading: boolean;
  error: string | null;
}

type Action =
  | { type: 'FETCH_START' }
  | { type: 'FETCH_SUCCESS'; payload: User }
  | { type: 'FETCH_ERROR'; payload: string }
  | { type: 'LOGOUT' };

function userReducer(state: State, action: Action): State {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };

    case 'FETCH_SUCCESS':
      return { user: action.payload, loading: false, error: null };

    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.payload };

    case 'LOGOUT':
      return { user: null, loading: false, error: null };

    default:
      return state;
  }
}

function useUser() {
  const [state, dispatch] = useReducer(userReducer, {
    user: null,
    loading: false,
    error: null,
  });

  const fetchUser = useCallback(async (id: string) => {
    dispatch({ type: 'FETCH_START' });

    try {
      const response = await fetch(`/api/users/${id}`);
      const user = await response.json();
      dispatch({ type: 'FETCH_SUCCESS', payload: user });
    } catch (error) {
      dispatch({ type: 'FETCH_ERROR', payload: error.message });
    }
  }, []);

  const logout = useCallback(() => {
    dispatch({ type: 'LOGOUT' });
  }, []);

  return { ...state, fetchUser, logout };
}
```

### Zustand：轻量级状态管理

```typescript
import { create } from 'zustand';
import { persist, devtools } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

// 定义 store
interface CartItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
}

interface CartStore {
  items: CartItem[];
  totalPrice: number;

  // Actions
  addItem: (item: Omit<CartItem, 'quantity'>) => void;
  removeItem: (id: string) => void;
  updateQuantity: (id: string, quantity: number) => void;
  clearCart: () => void;
}

export const useCartStore = create<CartStore>()(
  devtools(
    persist(
      immer((set) => ({
        items: [],
        totalPrice: 0,

        addItem: (item) =>
          set((state) => {
            const existing = state.items.find((i) => i.id === item.id);

            if (existing) {
              existing.quantity += 1;
            } else {
              state.items.push({ ...item, quantity: 1 });
            }

            state.totalPrice = state.items.reduce(
              (sum, item) => sum + item.price * item.quantity,
              0
            );
          }),

        removeItem: (id) =>
          set((state) => {
            state.items = state.items.filter((item) => item.id !== id);
            state.totalPrice = state.items.reduce(
              (sum, item) => sum + item.price * item.quantity,
              0
            );
          }),

        updateQuantity: (id, quantity) =>
          set((state) => {
            const item = state.items.find((i) => i.id === id);
            if (item) {
              item.quantity = quantity;
              state.totalPrice = state.items.reduce(
                (sum, item) => sum + item.price * item.quantity,
                0
              );
            }
          }),

        clearCart: () =>
          set((state) => {
            state.items = [];
            state.totalPrice = 0;
          }),
      })),
      {
        name: 'cart-storage', // localStorage key
      }
    )
  )
);

// 使用 store
function ShoppingCart() {
  const { items, totalPrice, removeItem, updateQuantity } = useCartStore();

  return (
    <div>
      <h2>购物车</h2>
      {items.map((item) => (
        <div key={item.id}>
          <span>{item.name}</span>
          <input
            type="number"
            value={item.quantity}
            onChange={(e) => updateQuantity(item.id, Number(e.target.value))}
          />
          <span>${item.price * item.quantity}</span>
          <button onClick={() => removeItem(item.id)}>删除</button>
        </div>
      ))}
      <div>总计: ${totalPrice}</div>
    </div>
  );
}

// 选择器优化性能
function CartBadge() {
  // 只订阅 items.length，避免不必要的重渲染
  const itemCount = useCartStore((state) =>
    state.items.reduce((sum, item) => sum + item.quantity, 0)
  );

  return <span className="badge">{itemCount}</span>;
}
```

### 服务器状态管理：React Query / TanStack Query

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// API 函数
async function fetchPosts(): Promise<Post[]> {
  const response = await fetch('/api/posts');
  if (!response.ok) throw new Error('Failed to fetch posts');
  return response.json();
}

async function fetchPost(id: string): Promise<Post> {
  const response = await fetch(`/api/posts/${id}`);
  if (!response.ok) throw new Error('Failed to fetch post');
  return response.json();
}

async function createPost(data: CreatePostDto): Promise<Post> {
  const response = await fetch('/api/posts', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!response.ok) throw new Error('Failed to create post');
  return response.json();
}

// 使用 Query
function PostList() {
  const {
    data: posts,
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts,
    staleTime: 5 * 60 * 1000, // 5 分钟内不重新获取
    gcTime: 10 * 60 * 1000, // 缓存保留 10 分钟
    retry: 3, // 失败后重试 3 次
  });

  if (isLoading) return <div>加载中...</div>;
  if (error) return <div>错误: {error.message}</div>;

  return (
    <div>
      <button onClick={() => refetch()}>刷新</button>
      {posts?.map((post) => (
        <PostItem key={post.id} post={post} />
      ))}
    </div>
  );
}

// 使用 Mutation
function CreatePostForm() {
  const queryClient = useQueryClient();
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');

  const createPostMutation = useMutation({
    mutationFn: createPost,
    onMutate: async (newPost) => {
      // 取消正在进行的查询
      await queryClient.cancelQueries({ queryKey: ['posts'] });

      // 保存之前的数据（用于回滚）
      const previousPosts = queryClient.getQueryData(['posts']);

      // 乐观更新
      queryClient.setQueryData(['posts'], (old: Post[] = []) => [
        ...old,
        { ...newPost, id: 'temp-id', createdAt: new Date().toISOString() },
      ]);

      return { previousPosts };
    },
    onError: (err, newPost, context) => {
      // 回滚到之前的数据
      queryClient.setQueryData(['posts'], context?.previousPosts);
    },
    onSettled: () => {
      // 无论成功还是失败，都重新获取数据
      queryClient.invalidateQueries({ queryKey: ['posts'] });
    },
  });

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    createPostMutation.mutate({ title, content });
    setTitle('');
    setContent('');
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder="标题"
      />
      <textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        placeholder="内容"
      />
      <button type="submit" disabled={createPostMutation.isPending}>
        {createPostMutation.isPending ? '发布中...' : '发布'}
      </button>
      {createPostMutation.error && (
        <div>错误: {createPostMutation.error.message}</div>
      )}
    </form>
  );
}

// 预取数据
function PostListWithPrefetch() {
  const queryClient = useQueryClient();
  const { data: posts } = useQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts,
  });

  const handleMouseEnter = (postId: string) => {
    // 预取单个文章数据
    queryClient.prefetchQuery({
      queryKey: ['post', postId],
      queryFn: () => fetchPost(postId),
      staleTime: 5 * 60 * 1000,
    });
  };

  return (
    <div>
      {posts?.map((post) => (
        <Link
          key={post.id}
          to={`/posts/${post.id}`}
          onMouseEnter={() => handleMouseEnter(post.id)}
        >
          {post.title}
        </Link>
      ))}
    </div>
  );
}

// 无限滚动
function InfinitePosts() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ['posts', 'infinite'],
    queryFn: ({ pageParam = 1 }) =>
      fetch(`/api/posts?page=${pageParam}`).then(res => res.json()),
    getNextPageParam: (lastPage, pages) => {
      return lastPage.hasMore ? pages.length + 1 : undefined;
    },
    initialPageParam: 1,
  });

  return (
    <div>
      {data?.pages.map((page) =>
        page.posts.map((post: Post) => (
          <PostItem key={post.id} post={post} />
        ))
      )}

      {hasNextPage && (
        <button
          onClick={() => fetchNextPage()}
          disabled={isFetchingNextPage}
        >
          {isFetchingNextPage ? '加载中...' : '加载更多'}
        </button>
      )}
    </div>
  );
}
```

## 后端状态管理

### 会话管理

```typescript
import session from 'express-session';
import RedisStore from 'connect-redis';
import { createClient } from 'redis';

// 设置 Redis
const redisClient = createClient({
  url: process.env.REDIS_URL,
});
await redisClient.connect();

// 配置会话
app.use(
  session({
    store: new RedisStore({ client: redisClient }),
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: process.env.NODE_ENV === 'production',
      httpOnly: true,
      maxAge: 24 * 60 * 60 * 1000, // 24 小时
      sameSite: 'lax',
    },
  })
);

// 扩展 Session 类型
declare module 'express-session' {
  interface SessionData {
    userId: string;
    cart: CartItem[];
    preferences: UserPreferences;
  }
}

// 使用会话
app.post('/api/login', async (req, res) => {
  const { email, password } = req.body;
  const user = await authenticateUser(email, password);

  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  // 存储用户 ID 到会话
  req.session.userId = user.id;

  res.json({ success: true, user });
});

app.get('/api/cart', (req, res) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  // 从会话中获取购物车
  const cart = req.session.cart || [];
  res.json({ cart });
});

app.post('/api/cart', (req, res) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  const item = req.body;

  // 更新会话中的购物车
  req.session.cart = req.session.cart || [];
  req.session.cart.push(item);

  res.json({ cart: req.session.cart });
});
```

### 缓存策略

```typescript
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

// 缓存装饰器
function Cache(options: {
  key: string;
  ttl?: number;
}) {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const cacheKey = `${options.key}:${JSON.stringify(args)}`;

      // 尝试从缓存获取
      const cached = await redis.get(cacheKey);
      if (cached) {
        console.log('Cache hit:', cacheKey);
        return JSON.parse(cached);
      }

      // 执行原方法
      console.log('Cache miss:', cacheKey);
      const result = await originalMethod.apply(this, args);

      // 存入缓存
      const ttl = options.ttl || 300; // 默认 5 分钟
      await redis.setex(cacheKey, ttl, JSON.stringify(result));

      return result;
    };

    return descriptor;
  };
}

// 使用缓存
class ProductService {
  @Cache({ key: 'product', ttl: 600 })
  async getProduct(id: string): Promise<Product> {
    return await prisma.product.findUnique({
      where: { id },
      include: { category: true, reviews: true },
    });
  }

  @Cache({ key: 'products:list', ttl: 300 })
  async getProducts(filters: ProductFilters): Promise<Product[]> {
    return await prisma.product.findMany({
      where: filters,
      orderBy: { createdAt: 'desc' },
    });
  }

  async updateProduct(id: string, data: UpdateProductDto): Promise<Product> {
    const product = await prisma.product.update({
      where: { id },
      data,
    });

    // 清除相关缓存
    await this.invalidateCache(id);

    return product;
  }

  private async invalidateCache(id: string) {
    const keys = await redis.keys(`product:*${id}*`);
    if (keys.length > 0) {
      await redis.del(...keys);
    }

    // 清除列表缓存
    const listKeys = await redis.keys('products:list:*');
    if (listKeys.length > 0) {
      await redis.del(...listKeys);
    }
  }
}

// 多级缓存
class CacheManager {
  private memoryCache = new Map<string, { value: any; expiry: number }>();

  async get<T>(key: string): Promise<T | null> {
    // 1. 检查内存缓存
    const memoryCached = this.memoryCache.get(key);
    if (memoryCached && memoryCached.expiry > Date.now()) {
      return memoryCached.value;
    }

    // 2. 检查 Redis 缓存
    const redisCached = await redis.get(key);
    if (redisCached) {
      const value = JSON.parse(redisCached);

      // 回填内存缓存
      this.memoryCache.set(key, {
        value,
        expiry: Date.now() + 60 * 1000, // 内存缓存 1 分钟
      });

      return value;
    }

    return null;
  }

  async set(key: string, value: any, ttl: number) {
    // 同时设置内存和 Redis 缓存
    this.memoryCache.set(key, {
      value,
      expiry: Date.now() + Math.min(ttl, 60) * 1000,
    });

    await redis.setex(key, ttl, JSON.stringify(value));
  }

  async delete(key: string) {
    this.memoryCache.delete(key);
    await redis.del(key);
  }
}
```

### 状态同步：WebSocket

```typescript
import { Server } from 'socket.io';
import { createServer } from 'http';

const httpServer = createServer(app);
const io = new Server(httpServer, {
  cors: {
    origin: process.env.CLIENT_URL,
    credentials: true,
  },
});

// 认证中间件
io.use(async (socket, next) => {
  const token = socket.handshake.auth.token;

  try {
    const user = await verifyToken(token);
    socket.data.userId = user.id;
    next();
  } catch (error) {
    next(new Error('Authentication error'));
  }
});

// 房间管理
const rooms = new Map<string, Set<string>>();

io.on('connection', (socket) => {
  const userId = socket.data.userId;
  console.log('User connected:', userId);

  // 加入房间
  socket.on('join-document', (documentId: string) => {
    socket.join(documentId);

    if (!rooms.has(documentId)) {
      rooms.set(documentId, new Set());
    }
    rooms.get(documentId)!.add(userId);

    // 通知其他用户
    socket.to(documentId).emit('user-joined', {
      userId,
      users: Array.from(rooms.get(documentId)!),
    });
  });

  // 文档协同编辑
  socket.on('document-change', async (data: {
    documentId: string;
    changes: any;
  }) => {
    const { documentId, changes } = data;

    // 保存到数据库
    await prisma.documentVersion.create({
      data: {
        documentId,
        changes,
        userId,
      },
    });

    // 广播给房间内的其他用户
    socket.to(documentId).emit('document-updated', {
      userId,
      changes,
      timestamp: new Date().toISOString(),
    });
  });

  // 光标位置同步
  socket.on('cursor-move', (data: {
    documentId: string;
    position: { line: number; column: number };
  }) => {
    socket.to(data.documentId).emit('cursor-moved', {
      userId,
      position: data.position,
    });
  });

  // 离开房间
  socket.on('leave-document', (documentId: string) => {
    socket.leave(documentId);

    const room = rooms.get(documentId);
    if (room) {
      room.delete(userId);

      if (room.size === 0) {
        rooms.delete(documentId);
      }

      socket.to(documentId).emit('user-left', {
        userId,
        users: Array.from(room),
      });
    }
  });

  // 断开连接
  socket.on('disconnect', () => {
    console.log('User disconnected:', userId);

    // 从所有房间移除
    rooms.forEach((room, documentId) => {
      if (room.has(userId)) {
        room.delete(userId);
        io.to(documentId).emit('user-left', {
          userId,
          users: Array.from(room),
        });
      }
    });
  });
});

// 前端使用 Socket.IO
import { io, Socket } from 'socket.io-client';

class DocumentSync {
  private socket: Socket;

  constructor(private documentId: string) {
    this.socket = io(process.env.API_URL, {
      auth: {
        token: localStorage.getItem('token'),
      },
    });

    this.setupListeners();
  }

  private setupListeners() {
    this.socket.on('connect', () => {
      console.log('Connected');
      this.socket.emit('join-document', this.documentId);
    });

    this.socket.on('user-joined', (data) => {
      console.log('User joined:', data);
      // 更新在线用户列表
    });

    this.socket.on('document-updated', (data) => {
      console.log('Document updated:', data);
      // 应用变更到本地编辑器
      this.applyChanges(data.changes);
    });

    this.socket.on('cursor-moved', (data) => {
      // 更新其他用户的光标位置
      this.updateCursor(data.userId, data.position);
    });
  }

  sendChanges(changes: any) {
    this.socket.emit('document-change', {
      documentId: this.documentId,
      changes,
    });
  }

  sendCursorPosition(position: { line: number; column: number }) {
    this.socket.emit('cursor-move', {
      documentId: this.documentId,
      position,
    });
  }

  disconnect() {
    this.socket.emit('leave-document', this.documentId);
    this.socket.disconnect();
  }
}
```

## 总结

全栈状态管理的关键原则：

1. **单一数据源**：每个状态应该有明确的所有者
2. **最小化共享状态**：尽可能使用局部状态
3. **合理使用缓存**：平衡性能和一致性
4. **乐观更新**：提升用户体验，但要处理失败情况
5. **状态同步**：保持客户端和服务器状态的一致性

选择合适的状态管理方案取决于：
- 应用规模和复杂度
- 团队技术栈和经验
- 性能和可扩展性需求
- 实时性要求

记住，没有完美的解决方案，只有最适合当前场景的方案。

## 参考资源

- [TanStack Query Documentation](https://tanstack.com/query/latest)
- [Zustand Documentation](https://docs.pmnd.rs/zustand/getting-started/introduction)
- [Socket.IO Documentation](https://socket.io/docs/v4/)
- [Redis Best Practices](https://redis.io/docs/manual/patterns/)
