---
title: Next.js 渲染策略与实时通信
description: SSR、SSG、PPR 渲染策略以及 SSE 实时数据流
author: Franvy
date: 2025-11-11
---

![](https://s2.loli.net/2025/12/11/NsyJfCmaYO5vwWd.jpg)

## 两个 "SSR"

在 Next.js 中，"SSR" 可能指两个不同概念：

1. **Server-Side Rendering**：服务端渲染，页面在服务器生成 HTML
2. **Server-Sent Events**：服务器推送事件，实时数据流

---

## Part 1: 渲染策略

### 策略概览

```
Next.js 渲染策略

SSG (Static Site Generation)
└─ 构建时生成静态 HTML
└─ 适用：博客、文档、营销页面

ISR (Incremental Static Regeneration)
└─ 静态生成 + 定期重新验证
└─ 适用：电商产品页、新闻

SSR (Server-Side Rendering)
└─ 每次请求时生成 HTML
└─ 适用：个性化内容、实时数据

PPR (Partial Prerendering) ← Next.js 15/16 新增
└─ 静态外壳 + 动态内容流式传输
└─ 适用：混合静态和动态的页面

CSR (Client-Side Rendering)
└─ 浏览器中渲染
└─ 适用：交互密集型应用
```

---

### SSG：静态生成

```tsx
// app/blog/[slug]/page.tsx
import { getPost, getAllPosts } from "@/lib/blog"

// 构建时生成所有页面
export async function generateStaticParams() {
  const posts = await getAllPosts()
  return posts.map((post) => ({ slug: post.slug }))
}

export default async function BlogPost({
  params,
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = await params
  const post = await getPost(slug)

  return (
    <article>
      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  )
}
```

**特点：**
- ✅ 极快响应（CDN 直接返回）
- ✅ 服务器负载极低
- ❌ 内容更新需要重新构建

---

### ISR：增量静态再生成

```tsx
// app/products/[id]/page.tsx
export const revalidate = 3600 // 每小时重新验证

export default async function ProductPage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const product = await getProduct(id)

  return (
    <div>
      <h1>{product.name}</h1>
      <p>¥{product.price}</p>
      <small>页面生成时间：{new Date().toLocaleString()}</small>
    </div>
  )
}
```

**工作流程：**
1. 首次访问：返回构建时的页面
2. 超过 revalidate 时间后：后台重新生成
3. 下次访问：返回更新后的页面

---

### SSR：动态服务端渲染

```tsx
// app/profile/page.tsx
import { cookies } from "next/headers"

export default async function ProfilePage() {
  // 读取 cookie 触发动态渲染
  const cookieStore = await cookies()
  const userId = cookieStore.get("user_id")?.value

  const user = await prisma.user.findUnique({
    where: { id: userId },
  })

  return (
    <div>
      <h1>欢迎，{user?.name}</h1>
      <p>邮箱：{user?.email}</p>
    </div>
  )
}
```

**特点：**
- ✅ 每次请求都是最新数据
- ✅ 支持个性化内容
- ❌ TTFB 较慢
- ❌ 服务器负载高

---

### PPR：部分预渲染（Next.js 15/16）

PPR 是 Next.js 最重要的新特性，结合了静态和动态的优点：

```tsx
// next.config.ts
export default {
  experimental: {
    ppr: "incremental", // Next.js 15
  },
  // 或 Next.js 16
  // cacheComponents: true,
}
```

```tsx
// app/dashboard/page.tsx
import { Suspense } from "react"

// 静态外壳
export default function DashboardPage() {
  return (
    <div>
      {/* 静态内容：立即返回 */}
      <Header />
      <Sidebar />

      {/* 动态内容：流式传输 */}
      <Suspense fallback={<StatsSkeleton />}>
        <DynamicStats />
      </Suspense>

      <Suspense fallback={<ActivitySkeleton />}>
        <RecentActivity />
      </Suspense>
    </div>
  )
}

// 动态组件
async function DynamicStats() {
  const stats = await fetchStats() // 数据库查询
  return <StatsCard data={stats} />
}

async function RecentActivity() {
  const activity = await fetchActivity()
  return <ActivityList data={activity} />
}
```

**PPR 工作流程：**

```
请求 → 立即返回静态 HTML 外壳
      ↓
      并行流式传输动态内容
      ↓
      Suspense 边界逐个替换为真实内容
```

**优势：**
- ✅ 即时的首屏加载（静态外壳）
- ✅ 动态内容并行加载
- ✅ 单个 HTTP 请求完成所有内容
- ✅ 比传统 SSR 快 40%+

---

### CSR：客户端渲染

```tsx
"use client"

import { useEffect, useState } from "react"

export default function Dashboard() {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetch("/api/dashboard")
      .then((res) => res.json())
      .then((data) => {
        setData(data)
        setLoading(false)
      })
  }, [])

  if (loading) return <div>加载中...</div>

  return (
    <div>
      <h1>仪表盘</h1>
      <p>用户数：{data.users}</p>
    </div>
  )
}
```

**特点：**
- ✅ 适合交互密集型应用
- ❌ SEO 不友好
- ❌ 首屏加载慢

---

### 渲染策略选择

| 场景 | 推荐策略 |
|------|----------|
| 博客、文档 | SSG |
| 产品页（价格每小时更新） | ISR |
| 用户个人页面 | SSR 或 PPR |
| 混合静态+动态 | PPR |
| 后台管理系统 | CSR |

---

## Part 2: Server-Sent Events（SSE）

### 为什么 2025 是 SSE 之年？

随着 AI 应用（如 ChatGPT）的普及，SSE 成为流式响应的首选：

- **LLM 流式输出**：每个 AI 聊天应用都需要
- **单向数据流**：服务器 → 客户端
- **HTTP 兼容**：无需 WebSocket 协议升级
- **自动重连**：浏览器原生支持

**SSE vs WebSocket：**

| 特性 | SSE | WebSocket |
|------|-----|-----------|
| **通信方向** | 单向 | 双向 |
| **协议** | HTTP | WS |
| **自动重连** | ✅ | ❌ |
| **适用场景** | AI 流式、通知、日志 | 聊天、游戏 |

---

### 基础实现

**服务端（Route Handler）：**

```typescript
// app/api/events/route.ts
export const dynamic = "force-dynamic"

export async function GET(request: Request) {
  const encoder = new TextEncoder()

  const stream = new ReadableStream({
    async start(controller) {
      // 心跳：防止代理超时
      const heartbeat = setInterval(() => {
        controller.enqueue(encoder.encode(": heartbeat\n\n"))
      }, 15000)

      // 发送数据
      const sendEvent = (data: object) => {
        const message = `data: ${JSON.stringify(data)}\n\n`
        controller.enqueue(encoder.encode(message))
      }

      // 示例：每秒发送时间
      const interval = setInterval(() => {
        sendEvent({ time: new Date().toISOString() })
      }, 1000)

      // 清理
      request.signal.addEventListener("abort", () => {
        clearInterval(heartbeat)
        clearInterval(interval)
        controller.close()
      })
    },
  })

  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive",
    },
  })
}
```

**客户端：**

```tsx
"use client"

import { useEffect, useState } from "react"

export function SSEClient() {
  const [messages, setMessages] = useState<string[]>([])
  const [status, setStatus] = useState("connecting")

  useEffect(() => {
    const eventSource = new EventSource("/api/events")

    eventSource.onopen = () => setStatus("connected")

    eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data)
      setMessages((prev) => [...prev.slice(-50), data.time])
    }

    eventSource.onerror = () => {
      setStatus("reconnecting")
      // EventSource 会自动重连
    }

    return () => eventSource.close()
  }, [])

  return (
    <div>
      <p>状态: {status}</p>
      <ul>
        {messages.map((msg, i) => (
          <li key={i}>{msg}</li>
        ))}
      </ul>
    </div>
  )
}
```

---

### AI 流式响应（最常见用例）

```typescript
// app/api/chat/route.ts
import OpenAI from "openai"

const openai = new OpenAI()

export async function POST(request: Request) {
  const { message } = await request.json()
  const encoder = new TextEncoder()

  const stream = new ReadableStream({
    async start(controller) {
      try {
        const completion = await openai.chat.completions.create({
          model: "gpt-4",
          messages: [{ role: "user", content: message }],
          stream: true,
        })

        for await (const chunk of completion) {
          const content = chunk.choices[0]?.delta?.content || ""
          if (content) {
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify({ content })}\n\n`)
            )
          }
        }

        controller.enqueue(encoder.encode("data: [DONE]\n\n"))
        controller.close()
      } catch (error) {
        controller.error(error)
      }
    },
  })

  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache, no-transform",
    },
  })
}
```

**客户端（AI 聊天）：**

```tsx
"use client"

import { useState } from "react"

export function ChatBox() {
  const [input, setInput] = useState("")
  const [response, setResponse] = useState("")
  const [loading, setLoading] = useState(false)

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    setLoading(true)
    setResponse("")

    const res = await fetch("/api/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ message: input }),
    })

    const reader = res.body?.getReader()
    const decoder = new TextDecoder()

    while (true) {
      const { done, value } = await reader!.read()
      if (done) break

      const chunk = decoder.decode(value)
      const lines = chunk.split("\n")

      for (const line of lines) {
        if (line.startsWith("data: ") && line !== "data: [DONE]") {
          const data = JSON.parse(line.slice(6))
          setResponse((prev) => prev + data.content)
        }
      }
    }

    setLoading(false)
  }

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="输入消息..."
          disabled={loading}
        />
        <button type="submit" disabled={loading}>
          发送
        </button>
      </form>
      <div className="response">
        {response}
        {loading && <span className="cursor">|</span>}
      </div>
    </div>
  )
}
```

---

### 进度条实现

```typescript
// app/api/upload/route.ts
export async function POST(request: Request) {
  const formData = await request.formData()
  const file = formData.get("file") as File
  const encoder = new TextEncoder()

  const stream = new ReadableStream({
    async start(controller) {
      const bytes = await file.arrayBuffer()
      const buffer = Buffer.from(bytes)
      const chunkSize = 1024 * 1024 // 1MB
      const totalChunks = Math.ceil(buffer.length / chunkSize)

      for (let i = 0; i < totalChunks; i++) {
        // 模拟处理延迟
        await new Promise((r) => setTimeout(r, 100))

        const progress = Math.round(((i + 1) / totalChunks) * 100)
        controller.enqueue(
          encoder.encode(`data: ${JSON.stringify({ progress })}\n\n`)
        )
      }

      controller.close()
    },
  })

  return new Response(stream, {
    headers: { "Content-Type": "text/event-stream" },
  })
}
```

---

### SSE 最佳实践

**1. 心跳机制（防止超时）**

```typescript
// 每 15 秒发送心跳
const heartbeat = setInterval(() => {
  controller.enqueue(encoder.encode(": heartbeat\n\n"))
}, 15000)
```

**2. 重连策略**

```tsx
useEffect(() => {
  let eventSource: EventSource | null = null
  let retryCount = 0
  const maxRetries = 5

  const connect = () => {
    eventSource = new EventSource("/api/events")

    eventSource.onopen = () => {
      retryCount = 0 // 重置重试计数
    }

    eventSource.onerror = () => {
      eventSource?.close()
      if (retryCount < maxRetries) {
        retryCount++
        setTimeout(connect, 1000 * retryCount) // 指数退避
      }
    }
  }

  connect()
  return () => eventSource?.close()
}, [])
```

**3. 使用 eventsource-parser（推荐）**

```bash
pnpm add eventsource-parser
```

```typescript
import { createParser } from "eventsource-parser"

const parser = createParser((event) => {
  if (event.type === "event") {
    const data = JSON.parse(event.data)
    // 处理数据
  }
})

// 流式解析
for await (const chunk of response.body) {
  parser.feed(new TextDecoder().decode(chunk))
}
```

---

## 总结

### 渲染策略选择

| 策略 | 首屏速度 | SEO | 数据实时性 | 适用场景 |
|------|----------|-----|------------|----------|
| SSG | 极快 | ✅ | ❌ | 博客、文档 |
| ISR | 快 | ✅ | 中 | 电商、新闻 |
| SSR | 中 | ✅ | ✅ | 个性化页面 |
| PPR | 极快 | ✅ | ✅ | 混合场景 |
| CSR | 慢 | ❌ | ✅ | 后台系统 |

### SSE 使用场景

- ✅ AI 流式响应（LLM 输出）
- ✅ 实时通知
- ✅ 进度条
- ✅ 日志流
- ❌ 双向通信（用 WebSocket）

---

**参考资料：**
- [Next.js Partial Prerendering](https://nextjs.org/docs/app/building-your-application/rendering/partial-prerendering)
- [Next.js 16 Cache Components](https://nextjs.org/blog)
- [SSE Best Practices 2025](https://hackernoon.com/streaming-in-nextjs-15-websockets-vs-server-sent-events)
- [eventsource-parser](https://www.npmjs.com/package/eventsource-parser)
