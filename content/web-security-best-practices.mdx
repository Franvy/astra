---
title: Web 安全最佳实践
description: 全面解析 Web 安全威胁与防御策略，包括 XSS、CSRF、SQL 注入等常见攻击及其防御方法
author: Claude AI
date: 2024-11-21
---

Web 安全是每个开发者都必须重视的领域。本文将深入探讨常见的安全威胁和对应的防御策略，帮助你构建更安全的 Web 应用。

## OWASP Top 10 安全风险

OWASP（开放式 Web 应用程序安全项目）定期发布最严重的 Web 应用安全风险清单。让我们逐一分析并提供防御方案。

## 1. 跨站脚本攻击 (XSS)

XSS 允许攻击者在受害者的浏览器中执行恶意脚本。

### 攻击类型

```typescript
// 存储型 XSS - 恶意脚本存储在数据库中
// 用户评论功能的漏洞示例
app.post('/api/comments', async (req, res) => {
  // ❌ 危险：直接存储用户输入
  await db.comments.create({
    content: req.body.content, // 可能包含 <script>alert('XSS')</script>
    userId: req.user.id,
  });
});

// 反射型 XSS - 恶意脚本在 URL 参数中
app.get('/search', (req, res) => {
  // ❌ 危险：直接输出用户输入
  res.send(`<h1>搜索结果：${req.query.q}</h1>`);
  // URL: /search?q=<script>alert('XSS')</script>
});

// DOM 型 XSS - 通过 JavaScript 操作 DOM
// ❌ 危险的前端代码
const searchQuery = new URLSearchParams(window.location.search).get('q');
document.getElementById('result').innerHTML = searchQuery;
```

### 防御策略

```typescript
// 1. 输入验证和清理
import { z } from 'zod';
import DOMPurify from 'isomorphic-dompurify';

const CommentSchema = z.object({
  content: z.string()
    .min(1)
    .max(1000)
    .refine(
      (val) => !/<script|javascript:|onerror=/i.test(val),
      'Invalid content'
    ),
});

app.post('/api/comments', async (req, res) => {
  // 验证输入
  const data = CommentSchema.parse(req.body);

  // 清理 HTML
  const sanitized = DOMPurify.sanitize(data.content, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'a'],
    ALLOWED_ATTR: ['href'],
  });

  await db.comments.create({
    content: sanitized,
    userId: req.user.id,
  });

  res.json({ success: true });
});

// 2. 输出编码
import escape from 'escape-html';

app.get('/search', (req, res) => {
  const query = escape(req.query.q);
  res.send(`<h1>搜索结果：${query}</h1>`);
});

// 3. React 自动转义
function CommentList({ comments }: { comments: Comment[] }) {
  return (
    <div>
      {comments.map(comment => (
        <div key={comment.id}>
          {/* React 自动转义文本内容 */}
          <p>{comment.content}</p>

          {/* 如果必须渲染 HTML，使用 DOMPurify */}
          <div
            dangerouslySetInnerHTML={{
              __html: DOMPurify.sanitize(comment.richContent)
            }}
          />
        </div>
      ))}
    </div>
  );
}

// 4. Content Security Policy (CSP)
app.use((req, res, next) => {
  res.setHeader(
    'Content-Security-Policy',
    [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline' https://trusted-cdn.com",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "font-src 'self' https://fonts.gstatic.com",
      "connect-src 'self' https://api.example.com",
      "frame-ancestors 'none'",
      "base-uri 'self'",
      "form-action 'self'",
    ].join('; ')
  );
  next();
});
```

## 2. SQL 注入攻击

SQL 注入允许攻击者执行任意 SQL 命令。

### 攻击示例

```typescript
// ❌ 危险：字符串拼接 SQL
app.get('/api/users/:id', async (req, res) => {
  const userId = req.params.id;

  // 如果 userId = "1 OR 1=1"，将返回所有用户
  const query = `SELECT * FROM users WHERE id = ${userId}`;
  const user = await db.raw(query);

  res.json(user);
});

// ❌ 危险：动态查询
app.get('/api/products', async (req, res) => {
  const { sort, order } = req.query;

  // 如果 sort = "price; DROP TABLE products--"
  const query = `SELECT * FROM products ORDER BY ${sort} ${order}`;
  const products = await db.raw(query);

  res.json(products);
});
```

### 防御策略

```typescript
// 1. 使用参数化查询（准备语句）
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

app.get('/api/users/:id', async (req, res) => {
  // ✅ 安全：Prisma 自动参数化
  const user = await prisma.user.findUnique({
    where: { id: req.params.id }
  });

  res.json(user);
});

// 2. 使用 ORM 的查询构建器
app.get('/api/products', async (req, res) => {
  const { category, minPrice } = req.query;

  // ✅ 安全：使用 ORM 构建查询
  const products = await prisma.product.findMany({
    where: {
      category: category as string,
      price: {
        gte: Number(minPrice),
      },
    },
    orderBy: { price: 'asc' },
  });

  res.json(products);
});

// 3. 白名单验证
const ALLOWED_SORT_FIELDS = ['price', 'name', 'createdAt'] as const;
const ALLOWED_ORDERS = ['asc', 'desc'] as const;

type SortField = typeof ALLOWED_SORT_FIELDS[number];
type SortOrder = typeof ALLOWED_ORDERS[number];

app.get('/api/products', async (req, res) => {
  const sort = req.query.sort as string;
  const order = req.query.order as string;

  // 验证输入
  if (!ALLOWED_SORT_FIELDS.includes(sort as SortField)) {
    return res.status(400).json({ error: 'Invalid sort field' });
  }

  if (!ALLOWED_ORDERS.includes(order as SortOrder)) {
    return res.status(400).json({ error: 'Invalid sort order' });
  }

  const products = await prisma.product.findMany({
    orderBy: { [sort]: order },
  });

  res.json(products);
});

// 4. 输入验证
import { z } from 'zod';

const ProductQuerySchema = z.object({
  category: z.string().max(50),
  minPrice: z.coerce.number().min(0),
  maxPrice: z.coerce.number().max(1000000),
  sort: z.enum(['price', 'name', 'createdAt']),
  order: z.enum(['asc', 'desc']),
});

app.get('/api/products', async (req, res) => {
  const query = ProductQuerySchema.parse(req.query);

  const products = await prisma.product.findMany({
    where: {
      category: query.category,
      price: {
        gte: query.minPrice,
        lte: query.maxPrice,
      },
    },
    orderBy: { [query.sort]: query.order },
  });

  res.json(products);
});
```

## 3. 跨站请求伪造 (CSRF)

CSRF 攻击利用用户已认证的会话，在用户不知情的情况下执行操作。

### 攻击场景

```html
<!-- 攻击者网站上的恶意代码 -->
<!-- 用户在已登录银行网站的情况下访问此页面 -->
<img src="https://bank.com/transfer?to=attacker&amount=10000" />

<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="to" value="attacker" />
  <input type="hidden" name="amount" value="10000" />
</form>
<script>
  document.forms[0].submit();
</script>
```

### 防御策略

```typescript
// 1. CSRF Token
import csrf from 'csurf';
import cookieParser from 'cookie-parser';

const csrfProtection = csrf({ cookie: true });

app.use(cookieParser());

// 获取 CSRF token
app.get('/api/csrf-token', csrfProtection, (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

// 验证 CSRF token
app.post('/api/transfer', csrfProtection, async (req, res) => {
  // 如果 token 无效，会自动返回 403
  const { to, amount } = req.body;

  await transferService.transfer({
    from: req.user.id,
    to,
    amount,
  });

  res.json({ success: true });
});

// 前端使用
import axios from 'axios';

// 获取 CSRF token
const { data } = await axios.get('/api/csrf-token');
const csrfToken = data.csrfToken;

// 在请求中包含 token
await axios.post('/api/transfer', {
  to: 'recipient',
  amount: 100,
}, {
  headers: {
    'X-CSRF-Token': csrfToken,
  },
});

// 2. SameSite Cookie
app.use(session({
  secret: process.env.SESSION_SECRET,
  cookie: {
    httpOnly: true,
    secure: true, // HTTPS only
    sameSite: 'strict', // 或 'lax'
    maxAge: 3600000,
  },
}));

// 3. 双重提交 Cookie
import crypto from 'crypto';

app.use((req, res, next) => {
  if (!req.cookies.csrf) {
    const token = crypto.randomBytes(32).toString('hex');
    res.cookie('csrf', token, {
      httpOnly: false, // 允许 JS 读取
      secure: true,
      sameSite: 'strict',
    });
  }
  next();
});

app.post('/api/protected', (req, res) => {
  const cookieToken = req.cookies.csrf;
  const headerToken = req.headers['x-csrf-token'];

  if (!cookieToken || cookieToken !== headerToken) {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }

  // 处理请求
  res.json({ success: true });
});

// 4. 验证 Origin/Referer
app.use((req, res, next) => {
  if (req.method === 'POST' || req.method === 'PUT' || req.method === 'DELETE') {
    const origin = req.headers.origin;
    const referer = req.headers.referer;
    const allowedOrigin = process.env.ALLOWED_ORIGIN;

    if (origin !== allowedOrigin && !referer?.startsWith(allowedOrigin)) {
      return res.status(403).json({ error: 'Invalid origin' });
    }
  }

  next();
});
```

## 4. 身份认证和会话管理

### 密码安全

```typescript
import bcrypt from 'bcrypt';
import { z } from 'zod';

// 密码策略
const PasswordSchema = z.string()
  .min(12, '密码至少12个字符')
  .regex(/[A-Z]/, '必须包含大写字母')
  .regex(/[a-z]/, '必须包含小写字母')
  .regex(/[0-9]/, '必须包含数字')
  .regex(/[^A-Za-z0-9]/, '必须包含特殊字符');

// 注册
app.post('/api/register', async (req, res) => {
  const { email, password } = req.body;

  // 验证密码强度
  PasswordSchema.parse(password);

  // 使用 bcrypt 加密（自动加盐）
  const hashedPassword = await bcrypt.hash(password, 12);

  const user = await prisma.user.create({
    data: {
      email,
      password: hashedPassword,
    },
  });

  res.json({ id: user.id, email: user.email });
});

// 登录
app.post('/api/login', async (req, res) => {
  const { email, password } = req.body;

  const user = await prisma.user.findUnique({
    where: { email },
  });

  if (!user) {
    // 使用通用错误消息，避免泄露用户是否存在
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  // 验证密码
  const valid = await bcrypt.compare(password, user.password);

  if (!valid) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  // 创建会话
  req.session.userId = user.id;

  res.json({ success: true });
});
```

### JWT 最佳实践

```typescript
import jwt from 'jsonwebtoken';
import { randomBytes } from 'crypto';

// 生成安全的 secret
const JWT_SECRET = process.env.JWT_SECRET || randomBytes(64).toString('hex');
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || randomBytes(64).toString('hex');

interface TokenPayload {
  userId: string;
  email: string;
  type: 'access' | 'refresh';
}

// 生成 token 对
function generateTokens(user: User) {
  // Access token：短期有效（15分钟）
  const accessToken = jwt.sign(
    {
      userId: user.id,
      email: user.email,
      type: 'access',
    } as TokenPayload,
    JWT_SECRET,
    { expiresIn: '15m' }
  );

  // Refresh token：长期有效（7天）
  const refreshToken = jwt.sign(
    {
      userId: user.id,
      email: user.email,
      type: 'refresh',
    } as TokenPayload,
    JWT_REFRESH_SECRET,
    { expiresIn: '7d' }
  );

  return { accessToken, refreshToken };
}

// 登录
app.post('/api/login', async (req, res) => {
  const { email, password } = req.body;

  const user = await authenticateUser(email, password);

  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  const { accessToken, refreshToken } = generateTokens(user);

  // 存储 refresh token（用于撤销）
  await prisma.refreshToken.create({
    data: {
      token: refreshToken,
      userId: user.id,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    },
  });

  // 将 refresh token 设置为 httpOnly cookie
  res.cookie('refreshToken', refreshToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });

  res.json({ accessToken });
});

// 刷新 token
app.post('/api/refresh', async (req, res) => {
  const refreshToken = req.cookies.refreshToken;

  if (!refreshToken) {
    return res.status(401).json({ error: 'No refresh token' });
  }

  try {
    // 验证 token
    const payload = jwt.verify(refreshToken, JWT_REFRESH_SECRET) as TokenPayload;

    if (payload.type !== 'refresh') {
      throw new Error('Invalid token type');
    }

    // 检查 token 是否被撤销
    const storedToken = await prisma.refreshToken.findFirst({
      where: {
        token: refreshToken,
        userId: payload.userId,
        expiresAt: { gt: new Date() },
      },
    });

    if (!storedToken) {
      throw new Error('Token revoked or expired');
    }

    // 生成新的 token 对
    const user = await prisma.user.findUnique({
      where: { id: payload.userId },
    });

    const tokens = generateTokens(user);

    // 删除旧的 refresh token
    await prisma.refreshToken.delete({
      where: { id: storedToken.id },
    });

    // 存储新的 refresh token
    await prisma.refreshToken.create({
      data: {
        token: tokens.refreshToken,
        userId: user.id,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      },
    });

    res.cookie('refreshToken', tokens.refreshToken, {
      httpOnly: true,
      secure: true,
      sameSite: 'strict',
      maxAge: 7 * 24 * 60 * 60 * 1000,
    });

    res.json({ accessToken: tokens.accessToken });

  } catch (error) {
    return res.status(401).json({ error: 'Invalid refresh token' });
  }
});

// 认证中间件
function authenticate(req: Request, res: Response, next: NextFunction) {
  const token = req.headers.authorization?.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }

  try {
    const payload = jwt.verify(token, JWT_SECRET) as TokenPayload;

    if (payload.type !== 'access') {
      throw new Error('Invalid token type');
    }

    req.user = { id: payload.userId, email: payload.email };
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}

// 登出
app.post('/api/logout', authenticate, async (req, res) => {
  const refreshToken = req.cookies.refreshToken;

  if (refreshToken) {
    // 撤销 refresh token
    await prisma.refreshToken.deleteMany({
      where: { token: refreshToken },
    });
  }

  res.clearCookie('refreshToken');
  res.json({ success: true });
});
```

## 5. 安全的 API 设计

```typescript
// 1. 速率限制
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

// 通用速率限制
const generalLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rl:general:',
  }),
  windowMs: 15 * 60 * 1000, // 15 分钟
  max: 100, // 最多 100 个请求
  message: 'Too many requests, please try again later',
});

// 认证端点的严格限制
const authLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rl:auth:',
  }),
  windowMs: 15 * 60 * 1000,
  max: 5, // 最多 5 次尝试
  skipSuccessfulRequests: true, // 成功的请求不计数
});

app.use('/api/', generalLimiter);
app.use('/api/login', authLimiter);
app.use('/api/register', authLimiter);

// 2. 输入验证
import { z } from 'zod';
import validator from 'validator';

const CreatePostSchema = z.object({
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title too long'),
  content: z.string()
    .min(10, 'Content too short')
    .max(10000, 'Content too long'),
  tags: z.array(z.string().max(50))
    .max(10, 'Too many tags'),
  url: z.string()
    .refine(val => validator.isURL(val), 'Invalid URL')
    .optional(),
});

app.post('/api/posts', authenticate, async (req, res) => {
  try {
    const data = CreatePostSchema.parse(req.body);

    const post = await prisma.post.create({
      data: {
        ...data,
        authorId: req.user.id,
      },
    });

    res.json(post);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ errors: error.errors });
    }
    throw error;
  }
});

// 3. 授权检查
async function authorizePostOwner(
  req: Request,
  res: Response,
  next: NextFunction
) {
  const postId = req.params.id;
  const userId = req.user.id;

  const post = await prisma.post.findUnique({
    where: { id: postId },
  });

  if (!post) {
    return res.status(404).json({ error: 'Post not found' });
  }

  if (post.authorId !== userId) {
    return res.status(403).json({ error: 'Forbidden' });
  }

  req.post = post;
  next();
}

app.put('/api/posts/:id', authenticate, authorizePostOwner, async (req, res) => {
  const data = CreatePostSchema.parse(req.body);

  const updated = await prisma.post.update({
    where: { id: req.params.id },
    data,
  });

  res.json(updated);
});

// 4. 防止信息泄露
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  // 记录详细错误（用于调试）
  console.error(err);

  // 只返回通用错误消息（避免泄露实现细节）
  if (process.env.NODE_ENV === 'production') {
    res.status(500).json({ error: 'Internal server error' });
  } else {
    res.status(500).json({ error: err.message, stack: err.stack });
  }
});
```

## 6. 安全 Headers

```typescript
import helmet from 'helmet';

app.use(helmet({
  // Content Security Policy
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "https://trusted-cdn.com"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https://api.example.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },

  // Strict-Transport-Security
  hsts: {
    maxAge: 31536000, // 1 year
    includeSubDomains: true,
    preload: true,
  },

  // X-Frame-Options
  frameguard: {
    action: 'deny',
  },

  // X-Content-Type-Options
  noSniff: true,

  // Referrer-Policy
  referrerPolicy: {
    policy: 'strict-origin-when-cross-origin',
  },
}));

// Permissions Policy
app.use((req, res, next) => {
  res.setHeader(
    'Permissions-Policy',
    'camera=(), microphone=(), geolocation=(self)'
  );
  next();
});
```

## 总结

Web 安全是一个持续的过程，需要：

1. **纵深防御**：使用多层安全措施
2. **最小权限原则**：只授予必要的权限
3. **输入验证**：永远不要信任用户输入
4. **安全默认**：默认使用最安全的配置
5. **持续学习**：关注最新的安全威胁和防御技术

记住，安全不是一次性的任务，而是需要在整个开发生命周期中持续关注的过程。

## 参考资源

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/)
- [MDN Web Security](https://developer.mozilla.org/en-US/docs/Web/Security)
- [Node.js Security Best Practices](https://nodejs.org/en/docs/guides/security/)
